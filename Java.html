<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Java - 沧海一粟No.1
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="沧海一粟No.1" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:nimitz871016.github.io ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        <li id=""><a target="_self" href="about.html">About</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; 沧海一粟No.1</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        
        <li><a target="_self" href="about.html">About</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Java.html">Java</a></li>
        
            <li><a href="MongoDB.html">MongoDB</a></li>
        
            <li><a href="iOS.html">iOS</a></li>
        
            <li><a href="LeetCode.html">LeetCode</a></li>
        
            <li><a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html">数据库</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15686164898705.html">
                
                  <h1>JSON反序列化乱序的问题</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">What</h2>

<p>将Object 转成JSON时，会出现key值的顺序与原顺序不一致的情况（新的顺序按照字母序重新排序）</p>

<h2 id="toc_1">Why</h2>

<p>原因在于HashMap，当用fastjson反序列化时，会使用HashMap。而HashMap底层会根据map中key的hashcode和equals重新排序。</p>

<h2 id="toc_2">How</h2>

<p>使用LinkedHashMap替换HashMap。</p>

<pre><code class="language-text">JSONObject jsonObj = new JSONObject(true);  
Map m= jsonObj.parseObject(json, LinkedHashMap.class);  
</code></pre>

<p>这个方法可以保证第一层的map按照原顺序呗反序列化。想要递归所有层都按照原顺序需要使用</p>

<pre><code class="language-text">HashMap m=JSON.parseObject(json,LinkedHashMap.class,Feature.OrderedField)；
</code></pre>

<h2 id="toc_3">PS</h2>

<p>Q: jackson 会乱序吗？<br/>
A: 不会</p>

<h2 id="toc_4">参考资料</h2>

<p><a href="https://github.com/alibaba/fastjson/issues/954">https://github.com/alibaba/fastjson/issues/954</a><br/>
<a href="https://blog.csdn.net/yj1499945/article/details/78260650">https://blog.csdn.net/yj1499945/article/details/78260650</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/09/16 14:48 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='JSON.html'>JSON</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15693104259267.html">
                
                  <h1>Jackson fasterxml和codehaus的区别</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>作为最出名的Json解析库之一，jackson有着两个完全不一样的包名版本。<code>com.fasterxml.jackson</code>&amp;&amp;<code>org.codehaus.jackson</code>。</p>

<p>这两个版本有什么区别呢？</p>

<p>他们是Jackson的两大分支、也是两个版本的不同包名。Jackson从2.0开始改用新的包名fasterxml；1.x版本的包名是codehaus。除了包名不同，他们的Maven artifact id也不同。1.x版本现在只提供bug-fix，而2.x版本还在不断开发和发布中。如果是新项目，建议直接用2x，即fasterxml jackson。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/09/24 15:33 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='JSON.html'>JSON</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15588755745673.html">
                
                  <h1>Java中的代理模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">1. 静态代理和动态代理</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;本章节参考了<a href="https://www.ibm.com/developerworks/cn/java/j-lo-proxy-pattern/">https://www.ibm.com/developerworks/cn/java/j-lo-proxy-pattern/</a></p>

<h3 id="toc_1">1.1. 定义</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;静态代理和动态代理指的是实现代理模式的方式。静态模式意思是所有的代码是静态写好的。而动态代理则相对，部分代码是动态生成的。在动态代理中还分为JDK动态代理和CGLib动态代理。</p>

<h3 id="toc_2">1.2. 关键实现</h3>

<h4 id="toc_3">1.2.1. 静态代理</h4>

<p>静态代理是基于接口实现的，他要求真实类和代理类实现同样的接口。</p>

<pre><code class="language-text">public interface IDBQuery {
    String request();
}
public class DBQuery implements IDBQuery{
    public DBQuery(){
        try{
            Thread.sleep(1000);//假设数据库连接等耗时操作
        }catch(InterruptedException ex){
            ex.printStackTrace();
        }
    }

    @Override
    public String request() {
// TODO Auto-generated method stub
        return &quot;request string&quot;;
    }


}
public class DBQueryProxy implements IDBQuery{
    private DBQuery real = null;

    @Override
    public String request() {
// TODO Auto-generated method stub
//在真正需要的时候才能创建真实对象，创建过程可能很慢
        if(real==null){
            real = new DBQuery();
        }//在多线程环境下，这里返回一个虚假类，类似于 Future 模式
        return real.request();
    }

}
public class Main {
    public static void main(String[] args){
        IDBQuery q = new DBQueryProxy(); //使用代里
        q.request(); //在真正使用时才创建真实对象
    }
}
</code></pre>

<h4 id="toc_4">1.2.2. JDK代理</h4>

<p>当使用JDK代理时，一个最直观的变化就是代理类不需要和真实类实现同一个接口了。取而代之的是代理类实现了InvocationHandler，并Override了invoke方法。在方法里可以统一对实现方法做处理（方法调用前，方法调用后）。</p>

<pre><code class="language-text">import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;


public class DBQueryHandler implements InvocationHandler{
    IDBQuery realQuery = null;//定义主题接口

    @Override
    public Object invoke(Object proxy, Method method, Object[] args)
            throws Throwable {
// TODO Auto-generated method stub
        //如果第一次调用，生成真实主题
        if(realQuery == null){
            realQuery = new DBQuery();
        }
        //method.invoke(target, args); 执行调用的方法。
        //返回真实主题完成实际的操作
        return realQuery.request();
    }
    public static IDBQuery createProxy(){
        IDBQuery proxy = (IDBQuery)Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{IDBQuery.class}, new DBQueryHandler()); // 注意，生成的代理类实例被强转为IDBQuery
        return proxy;
    }
}
</code></pre>

<h4 id="toc_5">1.2.3. CGLib代理</h4>

<p>CGLib一个直观的最大的特点就是真实类无需实现接口（当然实现了也没关系）。</p>

<p>接口类</p>

<pre><code class="language-text">public interface BookProxy {
    public void addBook();
}
</code></pre>

<p>实现类</p>

<pre><code class="language-text">//该类并没有申明 BookProxy 接口
public class BookProxyImpl {
    public void addBook() { 
        System.out.println(&quot;增加图书的普通方法...&quot;); 
    } 
}
</code></pre>

<p>代理类</p>

<pre><code class="language-text">import java.lang.reflect.Method; 
import net.sf.cglib.proxy.Enhancer; 
import net.sf.cglib.proxy.MethodInterceptor; 
import net.sf.cglib.proxy.MethodProxy;

public class BookProxyLib implements MethodInterceptor {
    private Object target;
    /**
     * 创建代理对象 
     *
     * @param target
     * @return
     */
    public Object getInstance(Object target) {
        this.target = target;
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(this.target.getClass());
        // 回调方法 
        enhancer.setCallback(this);
        // 创建代理对象 
        return enhancer.create();
    }

    @Override
// 回调方法 
    public Object intercept(Object obj, Method method, Object[] args,
                            MethodProxy proxy) throws Throwable {
        System.out.println(&quot;事物开始&quot;);
        proxy.invokeSuper(obj, args);
        System.out.println(&quot;事物结束&quot;);
        return null;
    }
}
</code></pre>

<p>调用方法</p>

<pre><code class="language-text">public class TestCglib { 
    public static void main(String[] args) { 
        BookProxyLib cglib=new BookProxyLib(); 
        BookProxyImpl bookCglib=(BookProxyImpl)cglib.getInstance(new BookProxyImpl()); 
        bookCglib.addBook();  //可以看到BookProxyLib并没有声明BookProxy接口，但是仍然可以调用addBook方法
    } 
}
</code></pre>

<h3 id="toc_6">1.3. 区别和共同点</h3>

<p>静态代理是通过在代码中显式定义一个业务实现类一个代理，在代理类中对同名的业务方法进行包装，用户通过代理类调用被包装过的业务方法；</p>

<p>JDK动态代理是通过接口中的方法名，在动态生成的代理类中调用业务实现类的同名方法；</p>

<p>CGlib动态代理是通过继承业务类，生成的动态代理类是业务类的子类，通过重写业务方法进行代理；</p>

<p><a href="https://blog.csdn.net/neosmith/article/details/51072840">https://blog.csdn.net/neosmith/article/details/51072840</a></p>

<h2 id="toc_7">2. 实际应用场景举例</h2>

<p>todo:没有理解cglib不用真实类实现接口的意义。因为真实类没有实现接口，但是暴露了public的方法。这和直接调用有啥区别？</p>

<p>另外cglib的试用场景，真实类没有实现的接口意义何在？如果没有接口来规范统一的调用逻辑，例如一堆的实现类实现了A接口，因此必须实现A接口中定义的B方法。这样才有意义吧？</p>

<p>查看spring源码，了解spring中，cglib的使用方法，来解答上述疑问。</p>

<p>代理模式的意义</p>

<ol>
<li>有代理，便于解耦</li>
<li>静态代理太麻烦，每个都要</li>
<li>JDK代理受限于要实现接口</li>
<li>CGLib不需要实现接口，看上去无法统一接口的方法，但是可能是用在一些common的方法，例如Object的方法。用在类创建时刻。</li>
<li>另外让方法运行只是最基本的，代理模式的最大用途是管理原方法的运行前，后，时（切面，AOP）。</li>
</ol>

<h2 id="toc_8">3. Spring AOP和动态代理</h2>

<h2 id="toc_9">4. OC中的动态代理模式浅谈</h2>

<h2 id="toc_10">5. CGLib和JDK代理的性能对比</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/05/26 20:59 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Java.html'>Java</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15479962056718.html">
                
                  <h1>Java并发编程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>&emsp;&emsp;本文对Java中的并发变成进行了简单的描述。是本人阅读《Java并发编程的艺术》一书的读书笔记。本文对重要的概念进行了记录。</p>

<p>&emsp;&emsp;本文首先介绍了各种各样的和锁相关的概念。然后介绍了Java多线程的技术要点，最后介绍了一些经典使用案例。</p>


                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                   <a href="15479962056718.html">Read more</a>&nbsp;&nbsp; 
                    <span class="date">2019/01/20 22:56 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Java.html'>Java</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15842883217984.html">
                
                  <h1>Java序列化的那些事</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">1. 什么是序列化和反序列化</h2>

<p>（1）Java序列化是指把Java对象转换为字节序列的过程，而Java反序列化是指把字节序列恢复为Java对象的过程；</p>

<p>（2）<strong>序列化：</strong>对象序列化的最主要的用处就是在传递和保存对象的时候，保证对象的完整性和可传递性。序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。序列化后的字节流保存了Java对象的状态以及相关的描述信息。序列化机制的核心作用就是对象状态的保存与重建。</p>

<p>（3）<strong>反序列化：</strong>客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。</p>

<p>（4）本质上讲，序列化就是把实体对象状态按照一定的格式写入到有序字节流，反序列化就是从有序字节流重建对象，恢复对象状态。</p>

<h2 id="toc_1">2、为什么需要序列化与反序列化</h2>

<p>我们知道，当两个进程进行远程通信时，可以相互发送各种类型的数据，包括文本、图片、音频、视频等， 而这些数据都会以二进制序列的形式在网络上传送。</p>

<p>那么当两个Java进程进行通信时，能否实现进程间的对象传送呢？答案是可以的！如何做到呢？这就需要Java序列化与反序列化了！</p>

<p>换句话说，一方面，发送方需要把这个Java对象转换为字节序列，然后在网络上传送；另一方面，接收方需要从字节序列中恢复出Java对象。</p>

<p>当我们明晰了为什么需要Java序列化和反序列化后，我们很自然地会想Java序列化的好处。其好处一是实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里），二是，利用序列化实现远程通信，即在网络上传送对象的字节序列。</p>

<p>总的来说可以归结为以下几点：</p>

<p>（1）永久性保存对象，保存对象的字节序列到本地文件或者数据库中；<br/>
（2）通过序列化以字节流的形式使对象在网络中进行传递和接收；<br/>
（3）通过序列化在进程间传递对象；</p>

<h2 id="toc_2">3、实现Java对象序列化与反序列化的方法</h2>

<p>假定一个User类，它的对象需要序列化，可以有如下三种方法：</p>

<p>（1）若User类仅仅实现了Serializable接口，则可以按照以下方式进行序列化和反序列化</p>

<p>ObjectOutputStream采用默认的序列化方式，对User对象的非transient的实例变量进行序列化。<br/>
ObjcetInputStream采用默认的反序列化方式，对对User对象的非transient的实例变量进行反序列化。</p>

<p>（2）若User类仅仅实现了Serializable接口，并且还定义了readObject(ObjectInputStream in)和writeObject(ObjectOutputSteam out)，则采用以下方式进行序列化与反序列化。</p>

<p>ObjectOutputStream调用User对象的writeObject(ObjectOutputStream out)的方法进行序列化。<br/>
ObjectInputStream会调用User对象的readObject(ObjectInputStream in)的方法进行反序列化。</p>

<p>（3）若User类实现了Externalnalizable接口，且User类必须实现readExternal(ObjectInput in)和writeExternal(ObjectOutput out)方法，则按照以下方式进行序列化与反序列化。</p>

<p>ObjectOutputStream调用User对象的writeExternal(ObjectOutput out))的方法进行序列化。<br/>
ObjectInputStream会调用User对象的readExternal(ObjectInput in)的方法进行反序列化。</p>

<h2 id="toc_3">4. serialVersionUID</h2>

<p>序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。为它赋予明确的值。显式地定义serialVersionUID有两种用途：</p>

<p>在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；</p>

<p>在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。</p>

<h2 id="toc_4">参考资料</h2>

<p>原文链接：<a href="https://blog.csdn.net/xlgen157387/article/details/79840134">https://blog.csdn.net/xlgen157387/article/details/79840134</a><br/>
<a href="https://blog.csdn.net/u014750606/article/details/80040130">https://blog.csdn.net/u014750606/article/details/80040130</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/03/16 00:05 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Java.html'>Java</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15819118469978.html">
                
                  <h1>一道LeetCode线程题引出Java线程协作的经典案例</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">1. 题目</h2>

<p><strong>1115. 交替打印FooBar</strong></p>

<p>我们提供一个类：</p>

<pre><code class="language-text">class FooBar {
  public void foo() {
    for (int i = 0; i &lt; n; i++) {
      print(&quot;foo&quot;);
    }
  }

  public void bar() {
    for (int i = 0; i &lt; n; i++) {
      print(&quot;bar&quot;);
    }
  }
}
</code></pre>

<p>两个不同的线程将会共用一个 FooBar 实例。其中一个线程将会调用 foo() 方法，另一个线程将会调用 bar() 方法。</p>

<p>请设计修改程序，以确保 &quot;foobar&quot; 被输出 n 次。</p>

<p> <br/>
示例 1:</p>

<pre><code class="language-text">输入: n = 1
输出: &quot;foobar&quot;
解释: 这里有两个线程被异步启动。其中一个调用 foo() 方法, 另一个调用 bar() 方法，&quot;foobar&quot; 将被输出一次。
</code></pre>

<p>示例 2:</p>

<pre><code class="language-text">输入: n = 2
输出: &quot;foobarfoobar&quot;
解释: &quot;foobar&quot; 将被输出两次。
</code></pre>

<p>来源：力扣（LeetCode）<br/>
链接：<a href="https://leetcode-cn.com/problems/print-foobar-alternately">https://leetcode-cn.com/problems/print-foobar-alternately</a><br/>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>

<h2 id="toc_1">2. 分析</h2>

<p>本题有两个要求</p>

<ol>
<li>顺序性，即foo要在bar之前打印，需要考虑先执行print bar的情况。</li>
<li>交替性，foo和bar需要轮流打印。</li>
</ol>

<h2 id="toc_2">2.1. 方案一（基于volatile）</h2>

<p>用一个变量来标记当前打印的是foo还是bar。这样就知道下一个操作需要打印foo还是bar。这个变量需要在线程间进行共享。共享没有问题，FooBar内的变量对同一个对象是可以访问的。但是需要能够及时同步。因此我们需要一个volatile变量。</p>

<p><strong>1.0版本:</strong></p>

<pre><code class="language-text">class FooBar {
    private int n;

    volatile boolean flag = true;

    public FooBar(int n) {
        this.n = n;
    }

    public void foo(Runnable printFoo) throws InterruptedException {
        for (int i = 0; i &lt; n; i++) {
            while (!flag){
            }
                // printFoo.run() outputs &quot;foo&quot;. Do not change or remove this line.
            printFoo.run();
            flag = false;
        }
    }

    public void bar(Runnable printBar) throws InterruptedException {

        for (int i = 0; i &lt; n; i++) {
                // printBar.run() outputs &quot;bar&quot;. Do not change or remove this line.
            while (flag){
            }
            printBar.run();
            flag = true;
        }
    }
}
</code></pre>

<p><img src="media/15819118469978/15819276109011.jpg" alt="" style="width:1142px;"/></p>

<p>提交，超时了。为啥呢？</p>

<p>考虑CPU单核的情况，<code>while (flag){}</code>如果是bar线程先运行，将会不停执行while。foo线程无法抢占时间片，自然无法开始第一步print foo了。在多核环境下，虽然不会造成另一线程无法抢占时间片的问题，但是while循环是很耗时的，占用大量CPU资源，这也会使得运行时间变长而超时。</p>

<p>基于这样的分析，修改一下，增加Thread.sleep()，每次循环的时候，休眠一会儿。</p>

<p><strong>2.0版本:</strong></p>

<pre><code class="language-text">class FooBar {
    private int n;

    volatile boolean flag = true;

    public FooBar(int n) {
        this.n = n;
    }

    public void foo(Runnable printFoo) throws InterruptedException {
        for (int i = 0; i &lt; n; i++) {
            while (!flag){
                Thread.sleep(20);
            }
                // printFoo.run() outputs &quot;foo&quot;. Do not change or remove this line.
            printFoo.run();
            flag = false;
        }
    }

    public void bar(Runnable printBar) throws InterruptedException {

        for (int i = 0; i &lt; n; i++) {
                // printBar.run() outputs &quot;bar&quot;. Do not change or remove this line.
            while (flag){
                Thread.sleep(20);
            }
            printBar.run();
            flag = true;
        }
    }
}
</code></pre>

<p>提交，进步了一点。还是<strong>超时</strong>。<br/>
<img src="media/15819118469978/15819276627967.jpg" alt="" style="width:1139px;"/></p>

<p>我们已经把休眠时间调整的很小了（20ms），希望程序可以快点切换到下一个打印。我们或许可以通过继续把休眠时间调整的更小来通过这道题，但是我们有一个更好的方法。<code>Thread.yield()</code></p>

<p><strong>3.0版本来了:</strong></p>

<pre><code class="language-text">class FooBar {
    private int n;

    volatile boolean flag = true;

    public FooBar(int n) {
        this.n = n;
    }

    public void foo(Runnable printFoo) throws InterruptedException {
        for (int i = 0; i &lt; n; i++) {
            while (!flag){
                Thread.yield();
            }
                // printFoo.run() outputs &quot;foo&quot;. Do not change or remove this line.
            printFoo.run();
            flag = false;
        }
    }

    public void bar(Runnable printBar) throws InterruptedException {

        for (int i = 0; i &lt; n; i++) {
                // printBar.run() outputs &quot;bar&quot;. Do not change or remove this line.
            while (flag){
                Thread.yield();
            }
            printBar.run();
            flag = true;
        }
    }
}
</code></pre>

<p><img src="media/15819118469978/15819289512587.jpg" alt="" style="width:1159px;"/><br/>
通过了！！！</p>

<pre><code class="language-text">摘抄自LeetCode评论：https://leetcode-cn.com/problems/print-foobar-alternately/solution/xian-cheng-ping-zhang-de-wen-ti-yi-ban-you-san-cho/
while循环是比较耗费性能的，可能会导致执行结果超时。可以通过Thread.yield进一步控制线程的执行，而非比较粗力度的循环。当某个线程调用yield()方法时，就会从运行状态转换到就绪状态后，CPU从就绪状态线程队列中只会选择与该线程优先级相同或者更高优先级的线程去执行。总之加上Thread.yield性能会更高一点，因此用时会更少
</code></pre>

<p>什么是Thread.yield()?</p>

<p>摘抄自：<a href="https://www.cnblogs.com/java-spring/p/8309931.html">https://www.cnblogs.com/java-spring/p/8309931.html</a></p>

<p>Java线程中的Thread.yield( )方法，译为线程让步。顾名思义，就是说当一个线程使用了这个方法之后，它就会把自己CPU执行的时间让掉，<br/>
让自己或者其它的线程运行，注意是让自己或者其他线程运行，并不是单纯的让给其他线程。<br/>
yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！<br/>
举个例子：一帮朋友在排队上公交车，轮到Yield的时候，他突然说：我不想先上去了，咱们大家来竞赛上公交车。然后所有人就一块冲向公交车，<br/>
有可能是其他人先上车了，也有可能是Yield先上车了。<br/>
但是线程是有优先级的，优先级越高的人，就一定能第一个上车吗？这是不一定的，优先级高的人仅仅只是第一个上车的概率大了一点而已，<br/>
最终第一个上车的，也有可能是优先级最低的人。并且所谓的优先级执行，是在大量执行次数中才能体现出来的。</p>

<h2 id="toc_3">2.2 方案二 Semaphore</h2>

<p>Semaphore<br/>
<a href="https://blog.csdn.net/hanchao5272/article/details/79780045">https://blog.csdn.net/hanchao5272/article/details/79780045</a></p>

<p>基于Semaphore的代码如下:</p>

<pre><code class="language-text">class FooBar {

    private int n;

    private Semaphore semaphore = new Semaphore(1);

    private volatile boolean foo = false;

    public FooBar(int n) {
        this.n = n;
    }

    public void foo(Runnable printFoo) throws InterruptedException {

        for (int i = 0; i &lt; n; i++) {
            semaphore.acquire();
            // printFoo.run() outputs &quot;foo&quot;. Do not change or remove this line.
            printFoo.run();
            foo = true;
        }
    }

    public void bar(Runnable printBar) throws InterruptedException {

        for (int i = 0; i &lt; n; i++) {
            while (!foo) {
            }
            // printBar.run() outputs &quot;bar&quot;. Do not change or remove this line.
            printBar.run();
            foo = false;
            semaphore.release();
        }
    }
}

作者：san-mu-32
链接：https://leetcode-cn.com/problems/print-foobar-alternately/solution/tong-guo-yi-ge-xin-hao-liang-kong-zhi-foohe-barde-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>

<p><img src="media/15819118469978/15819321426228.jpg" alt="" style="width:759px;"/></p>

<p>涉及多线程，运行时间并不稳定。和方案一类似，在while循环中加入Thread.yield()，速度有一定提升。<br/>
<img src="media/15819118469978/15819322651608.jpg" alt="" style="width:716px;"/></p>

<h2 id="toc_4">2.3. 方案三 notify &amp;&amp; wait</h2>

<p><a href="https://www.jianshu.com/p/1dafbf42cc54">https://www.jianshu.com/p/1dafbf42cc54</a></p>

<pre><code class="language-text">class FooBar {

    private int              n;
    private volatile boolean isFoo;

    public FooBar(int n) {
        this.n = n;
    }

    public synchronized void foo(Runnable printFoo) throws InterruptedException {

        for (int i = 0; i &lt; n; i++) {
            //            synchronized (lock) {
            // printFoo.run() outputs &quot;foo&quot;. Do not change or remove this line.
            printFoo.run();
            isFoo = true;
            this.notify();
            if (i &lt; n - 1) {
                this.wait();
            }
            //            }
        }
    }

    public synchronized void bar(Runnable printBar) throws InterruptedException {
        if (!isFoo) {
            this.wait();
        }
        for (int i = 0; i &lt; n; i++) {
            //            synchronized (lock) {
            // printBar.run() outputs &quot;bar&quot;. Do not change or remove this line.
            printBar.run();
            this.notify();
            if (i &lt; n - 1) {
                this.wait();
            }
            //            }
        }
    }
}
</code></pre>

<p><img src="media/15819118469978/15820959963519.jpg" alt="" style="width:747px;"/><br/>
运行时间不稳定，应该是LeetCode的问题。</p>

<h2 id="toc_5">2.4. 方案四 CyclicBarrier</h2>

<p><a href="https://www.jianshu.com/p/333fd8faa56e">https://www.jianshu.com/p/333fd8faa56e</a></p>

<pre><code class="language-text">class FooBar {
    private int n;

    public FooBar(int n) {
        this.n = n;
    }

    CyclicBarrier cb = new CyclicBarrier(2);
    volatile boolean fin = true;

    public void foo(Runnable printFoo) throws InterruptedException {
        for (int i = 0; i &lt; n; i++) {
            while(!fin);
            printFoo.run();
            fin = false;
            try {
        cb.await();
        } catch (BrokenBarrierException e) {
        }
        }
    }

    public void bar(Runnable printBar) throws InterruptedException {
        for (int i = 0; i &lt; n; i++) {
            try {
        cb.await();
        } catch (BrokenBarrierException e) {
        }
            printBar.run();
            fin = true;
        }
    }
}

作者：KevinBauer
链接：https://leetcode-cn.com/problems/print-foobar-alternately/solution/java-bing-fa-gong-ju-lei-da-lian-bing-by-kevinbaue/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>

<h2 id="toc_6">2.5. 方案五 CyclicBarrier + CountdownLatch</h2>

<p>CyclicBarrier用于保证每一轮的foobar的打印。CountdownLatch用于保证单轮内，先打印foo，再打印bar。</p>

<pre><code class="language-text">import java.util.concurrent.CountDownLatch;
import java.util.concurrent.CyclicBarrier;
class FooBar {
    private int n;
    private CountDownLatch a;
    private CyclicBarrier barrier;// 使用CyclicBarrier保证任务按组执行
    public FooBar(int n) {
        this.n = n;
        a = new CountDownLatch(1);
        barrier = new CyclicBarrier(2);// 保证每组内有两个任务
    }

    public void foo(Runnable printFoo) throws InterruptedException {

        try {
            for (int i = 0; i &lt; n; i++) {
                printFoo.run();
                a.countDown();// printFoo方法完成调用countDown
                barrier.await();// 等待printBar方法执行完成
            }
        } catch(Exception e) {}
    }

    public void bar(Runnable printBar) throws InterruptedException {

        try {
            for (int i = 0; i &lt; n; i++) {
                a.await();// 等待printFoo方法先执行
                printBar.run();
                a = new CountDownLatch(1); // 保证下一次依旧等待printFoo方法先执行
                barrier.await();// 等待printFoo方法执行完成
            }
        } catch(Exception e) {}
    }
}

作者：bonaluo
链接：https://leetcode-cn.com/problems/print-foobar-alternately/solution/javashi-yong-yi-ge-countdownlatchhe-yi-ge-cyclicba/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>

<h2 id="toc_7">3. 总结</h2>

<p>本题需要解决两个问题。</p>

<ol>
<li>两个线程必须先后执行，</li>
<li>foo线程必须保证先执行。</li>
</ol>

<p>为了解决这两个问题，5个方案选择了不同的方案组合。主要分为无锁和有锁两种方案。</p>

<p>为了解决foo线程先执行的问题。有使用volatile变量和CountdownLatch两种方法。volatile变量使用的是无锁的方案。通过一个死循环，组织bar线程先运行。优点是可以快速感知状态变换，无需线程切换。缺点是资源消耗大，需要使用Thread.yield()。否则会超时。CountdownLatch采用的是有锁的方案，因此会有线程的切换，单不会大量占用系统资源。在线程占用时间长的场景体验更佳。</p>

<p>为了让两个线程先后执行，需要在foo线程执行后挂起线程，让bar线程运行。在bar线程运行后，再让foo线程执行。无锁方案，继续用volatile变量即可。有锁方案则可以有几种选择。Semaphore，CyclicBarrier，notify&amp;wait，Lock。</p>

<h2 id="toc_8">4. 引申</h2>

<p>　　在 单核 / 单CPU 的系统上使用 自旋锁 是没有意义的，因为它就一个运行线程/核心，你占着不放，那么其他线程将得不到运行，其他线程得不到运行，这个锁就不能被解锁。换句话说，在 单核 / 单CPU 系统使用 自旋锁，除了浪费点时间外没有一点好处。这时如果让这个线程（记为线程A）休眠，其他线程就得以运行，然后就可能会解锁这个 自旋锁，线程A就可能在重新被唤醒后，如愿以偿的持有锁。</p>

<p>　　在 多核 / 多CPU 的系统上，特别是大量的线程只会短时间的持有锁的时候，这时如果使用 互斥锁，在使线程睡眠和唤醒上浪费大量的时间，也许会显著降低程序的运行性能。使用 自旋锁，线程可以充分利用系统调度程序分配的时间片(经常阻塞很短的时间，不用休眠，然后马上继续它们后面的工作了)，以达到更高的处理能力和吞吐量。</p>

<p><a href="https://www.cnblogs.com/shines77/p/4198046.html">https://www.cnblogs.com/shines77/p/4198046.html</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/02/17 11:57 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Java.html'>Java</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15542090064870.html">
                
                  <h1>从logger.isDebugEnabled()谈起</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">0. 问题</h2>

<p>在很多框架中，我们看到在<code>logger.debug</code>处经常会这样写</p>

<pre><code class="language-text">if (logger.isDebugEnabled()) {
    logger.debug(message);
}
</code></pre>

<p>我们知道<code>logger.debug()</code>,在日志级别不够的时候是不会输出日志的。那么这么写的目的何在？</p>

<h2 id="toc_1">1. 分析</h2>

<p>我们来看一个例子</p>

<pre><code class="language-text">String error = &quot;debug日志&quot;;
logger.debug(&quot;这是一个&quot; + error);
</code></pre>

<p>按照正常的逻辑，在执行logger.debug()之前需要先行计算括号里的内容。然后才会判断当前日志级别不符合不输出。这里就存在一个无用计算的过程。相比对直接执行语句对logger.isDebugEnabled()进行先判断，显然是一个更优的方案，避免了无用的计算过程。</p>

<p>然而这个结论在占位符的使用下，有了一点不同。</p>

<p>再来看一个例子</p>

<h3 id="toc_2">1.1. logger.debug(&quot;这是一个{}&quot;, model);</h3>

<pre><code class="language-text">public static class Model{
    int age;

    @Override
    public String toString() {
        System.out.println(&quot;toString called&quot;);
        return &quot;model{&quot; +
                &quot;age=&quot; + age +
                &#39;}&#39;;
    }
}
public static void main(String[] args) {
    Model model = new Model();
    model.age = 3;
    
    logger.debug(&quot;这是一个{}&quot;, model);
}
</code></pre>

<p>同样的作用，但是当日志级别高于debug时，不会执行括号内部的字符串拼接。也就是如果使用占位符{}来组合输出日志，可以不用判断<code>logger.isDebugEnabled()</code></p>

<h3 id="toc_3">1.2. logger.debug(&quot;test:{}&quot;, test());</h3>

<p>Model的toString方法在用占位符{}的方式时，没有执行，那么如果是一个普通的方法呢？</p>

<pre><code class="language-text">public static String test(){
    System.out.println(&quot;test&quot;);
    return &quot;test&quot;;
}
public static void main(String[] args) {
    logger.debug(&quot;test:{}&quot;, test()); //日志级别info
}
</code></pre>

<p>结果，logger.debug(&quot;test:{}&quot;, test());无输出，但是test()方法在控制台打印出了test。</p>

<p>结论：有占位符的存在，但是如果字符串拼接调用了函数，仍然会先执行函数，这和日志级别无关。</p>

<h3 id="toc_4">1.3. logger.debug(&quot;test2:{}, {}&quot;, model, test());</h3>

<pre><code class="language-text">public static String test(){
    System.out.println(&quot;print test&quot;);
    return &quot;fdsf&quot;;
}
public static void main(String[] args) {
    Model model = new Model();
    model.age = 3;
    logger.debug(&quot;test1:&quot; + model);
    model.age = 5;
    logger.debug(&quot;test2:{}, {}&quot;, model, test());
}
</code></pre>

<p>结果，最后一句debug，model的toString方法没有执行，而test()方法打印出了&quot;print test&quot;。也就是在占位符的作用下，对象的toString()方法不会执行，而不同方法仍然会执行。</p>

<h2 id="toc_5">2. 结论</h2>

<p>通过<code>logger.isDebugEnabled()</code>进行先行判断，肯定是没有错的。虽然在占位符的帮助下，当日志级别高于debug时，对象的toString()方法不会执行，但是普通的方法仍然会执行。如果能够保证logger.debug()中的内容只涉及最简单的字符串拼接和toString()，那么可以简略<code>logger.isDebugEnabled()</code>，否则还是加上避免无用计算。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/04/02 20:43 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Java.html'>Java</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15693167161716.html">
                
                  <h1>从使用fastjson替换springboot框架默认的json解析工具说起</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">1. 为什么要用fastjson替换jackson</h2>

<p>1.在默认情况下我们在的情况下从返回的数据是</p>

<p>json格式但是在{key,value}中key的值当中用默认的Jackson返还回来会忽略大小写而我们要得到得是不忽略大小写得值因此我</p>

<p>们需要用FastJson替代默认得Jackson</p>

<p>2.我们通常现在为了更快捷得创建类,使用lombok插件得@Data注解生成类得getter,setter及构造方法.jackson是不支持json格式</p>

<p>序列化的,但是FastJson是可以做到这一点的<br/>
————————————————<br/>
版权声明：本文为CSDN博主「Alin_林」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br/>
原文链接：<a href="https://blog.csdn.net/weixin_44828552/article/details/89511350">https://blog.csdn.net/weixin_44828552/article/details/89511350</a></p>

<h2 id="toc_1">2. 如何替换fastjson</h2>

<p>常见的替换方法有以下两种</p>

<h3 id="toc_2">2.1. 方法一</h3>

<pre><code class="language-text">@SpringBootApplication
public class HelloWorld implement ApplicationRunner{
    public static void main(String[] args){
        SpringApplication.run(HelloWorld.class,args);
    }

    @Bean
    public HttpMessageConverters fastJsonHttpMessageConverters(){
        //1.定义fastJson转换器
        FastJsonHttpMessageConverter fastConverter=new FastJsonHttpMessageConverter();
        FastJsonConfig fastJsonConfig=new FastJsonConfig();
        fastJsonConfig.setSerializerFeatures(SerialzerFeature.WriteMapNullValue, SerializerFeature.WriteNullListAsEmpty);
        fastConverter.setFastJsonConfig(fastJsonConfig);
        HttpMessageConverter&lt;?&gt; converter = fastConverter;
        return new HttpMessageConverters(converter);
    }   
}
</code></pre>

<h3 id="toc_3">2.2. 方法二</h3>

<pre><code class="language-text">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {
        FastJsonHttpMessageConverter fastJsonConverter = new FastJsonHttpMessageConverter();
        FastJsonConfig config = new FastJsonConfig();
        config.setCharset(Charset.forName(&quot;UTF-8&quot;));
//        config.setDateFormat(&quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&quot;);
//        config.setSerializerFeatures(SerializerFeature.WriteMapNullValue);
        fastJsonConverter.setFastJsonConfig(config);
        List&lt;MediaType&gt; list = new ArrayList&lt;&gt;();
        list.add(MediaType.APPLICATION_JSON_UTF8);
        fastJsonConverter.setSupportedMediaTypes(list);
        converters.add(fastJsonConverter);
    }
}
</code></pre>

<h2 id="toc_4">3. 发散分析</h2>

<h3 id="toc_5">3.1. Jackson的新版本</h3>

<p>网络上搜集替换jackson的理由，其中一点是jackson不支持忽略key大小写。</p>

<p>该点已经在2.5.0版本中解决。</p>

<pre><code class="language-text">ObjectMapper objectMapper = new ObjectMapper();
objectMapper.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);
CarInfo info = objectMapper.readValue(data, CarInfo.class); 
</code></pre>

<p>或在配置文件中</p>

<pre><code class="language-text">spring.jackson.mapper.accept_case_insensitive_properties=true
</code></pre>

<h3 id="toc_6">3.2. 从替换fastjson，看springboot使用json解析器的逻辑</h3>

<p>第二节中的两种方法都涉及到同一个类的使用，那就是<code>FastJsonHttpMessageConverter</code>和<code>HttpMessageConverter</code>。</p>

<p>将FastJsonHttpMessageConverter 添加到系统的HttpMessageConverter列表中，实际操作就是增加了一种json的解析方法，可以解析的media type是application-json，使用的解析器就是FastJsonHttpMessageConverter。</p>

<h2 id="toc_7">更多阅读</h2>

<h3 id="toc_8">1. 三种json解析工具对比</h3>

<p>fastjson这么快老外为啥还是热衷 jackson? <a href="https://blog.csdn.net/Amen_Wu/article/details/79129020">https://blog.csdn.net/Amen_Wu/article/details/79129020</a></p>

<p>FastJSON、Gson和Jackson性能对比和共同缺点,注意事项<br/>
<a href="https://blog.csdn.net/qq_28572235/article/details/78604846">https://blog.csdn.net/qq_28572235/article/details/78604846</a></p>

<h2 id="toc_9">参考资料</h2>

<p><a href="https://mtyurt.net/post/jackson-case-insensitive-deserialization.html">https://mtyurt.net/post/jackson-case-insensitive-deserialization.html</a><br/>
<a href="https://blog.csdn.net/weixin_44828552/article/details/89511350">https://blog.csdn.net/weixin_44828552/article/details/89511350</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/09/24 17:18 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='JSON.html'>JSON</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15839811744876.html">
                
                  <h1>用注解，自动扩展启动。</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><a href="https://blog.csdn.net/zzti_erlie/article/details/102988486?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task">https://blog.csdn.net/zzti_erlie/article/details/102988486?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/03/12 10:46 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Java.html'>Java</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15877086715482.html">
                
                  <h1>线程安全的对象你用对了吗？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>HashMap是线程不安全的，如果我们需要线程安全的使用场景，通常会使用ConcurrentHashMap来代替HashMap来保证线程安全。可是这样就够了吗？</p>

<p>我们用Mybatis源码中的一个例子来说明。</p>

<pre><code class="language-text">BlockingCache.java

private final ConcurrentHashMap&lt;Object, ReentrantLock&gt; locks;

// MyBatis的这个blocking cache保证同一个时间对于一个查询key只有一个线程可以获得锁。锁放在了locks这个ConcurrentHashMap中。每个线程要操作前需要尝试获取锁。以下就是获取锁的核心逻辑。注意这个方法本身是没有加锁保护的。
private ReentrantLock getLockForKey(Object key) {
    ReentrantLock lock = new ReentrantLock();
    ReentrantLock previous = locks.putIfAbsent(key, lock);
    return previous == null ? lock : previous;
    return locks.computeIfAbsent(key, (k) -&gt; new ReentrantLock());
}
</code></pre>

<p>关键是这一句</p>

<pre><code class="language-text">locks.putIfAbsent(key, lock);
</code></pre>

<p><code>putIfAbsent()</code> 是啥作用呢? 按照字面意思，就是如果key不存在，则set，否则不插入。为啥会用这样一个看起来有点复杂的接口呢?如果我们没有熟读ConcurrentHashMap提供的接口，我们可能会这么写：</p>

<pre><code class="language-text">private ReentrantLock getLockForKey(Object key) {
    ReentrantLock lock = locks.get(key); //  从map里读取一下是否key已经存放了
    if (lock == null) { // 不存在，则新建一个锁，加入到map中
      lock = new ReentrantLock();
      locks.put(key, lock);
    }
    return lock;
}
</code></pre>

<p>这段代码是我们日常很有可能写出的逻辑，逻辑清楚，代码也还算简洁。那这段代码会有什么问题呢？<br/>
<img src="media/15876583681202/15876624402012.jpg" alt="" style="width:768px;"/><br/>
一个有点挫的流程图，来解释一下。这段代码没有同步锁的保护，所以可能有多个线程同一时间都进入了这段代码。A线程先执行了1，2步骤，判断了map中没有key，准备创建线程并添加。这时候发生了线程切换，B线程开始执行这段代码。B线程也去判断map中有没有key，显然也是没有的。然后B线程走完了整个逻辑。然后A线程再一次获取到时间片。最终结果，A线程和B线程都往map中插入了他们自己创建的锁。很明显B线程的锁被覆盖了。</p>

<p>回过头来看一下源码中是怎么写的。</p>

<pre><code class="language-text">locks.putIfAbsent(key, lock);
</code></pre>

<p>源码使用了ConncurrentHashMap的一个接口来达到两个目的，1. 查询一下map中是否包含某个key值。2.不存在则插入。而调用这个接口，ConncurrentHashMap保证了两个步骤的原子性，即要么都做要么都不做。</p>

<h2 id="toc_0">总结</h2>

<p>ConncurrentHashMap虽然是线程安全的，但是用不好一样也会有线程不安全的问题。像这种线程安全的类，他们的单个接口是可以保证线程安全的，但是如果调用了多个接口，又没有用锁来保护，则仍然有可能发生线程不安全的问题。</p>

<p>引申一下，这个问题和Redis用lua脚本来保证多个redis命令的线程安全是有类似的地方。Redis执行单个命令是线程安全的。执行多个组合命令则要使用Lua脚本。这是因为执行Lua脚本命令是安全的。因此可以用Lua脚本来执行多个Redis命令来达到对多个Redis命令的原子性操作。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/04/24 14:11 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Java.html'>Java</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="asset/img/icon.jpg" /></div>
            
                <h1>沧海一粟No.1</h1>
                <div class="site-des">如果选择了远方，便只顾风雨兼程</div>
                <div class="social">









<a target="_blank" class="github" target="_blank" href="https://github.com/nimitz871016" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:nimitz_007@163.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Java.html"><strong>Java</strong></a>
        
            <a href="MongoDB.html"><strong>MongoDB</strong></a>
        
            <a href="iOS.html"><strong>iOS</strong></a>
        
            <a href="LeetCode.html"><strong>LeetCode</strong></a>
        
            <a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html"><strong>数据库</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15490058580119.html">102. 二叉树的层次遍历</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15490112223994.html">122. 买卖股票的最佳时机 II</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15814116703606.html">1349. 参加考试的最大学生数</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15500440104341.html">169. 求众数</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15500441189502.html">189. 旋转数组</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  














<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
